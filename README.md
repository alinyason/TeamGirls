#### **Для test1:**

---

Test Case 1: Проверка начального состояния игрока

Метод: test_initial_state()

Цель: Проверить корректность инициализации объекта игрока

Шаги:

Создать объект Player с параметрами (100, 100, 50, 50)

Проверить начальные значения атрибутов

Ожидаемые результаты:

player.rect.x == 100

player.rect.y == 100

player.direction == "right"

player.jump_count == 0

player.y_vel == 0

---

Test Case 2: Движение влево

Метод: test_movement() (первая часть)

Цель: Проверить корректность движения влево

Шаги:

Вызвать player.move_left(5)

Проверить изменения атрибутов

Ожидаемые результаты:

player.x_vel == -5

player.direction == "left"

---

Test Case 3: Движение вправо

Метод: test_movement() (вторая часть)

Цель: Проверить корректность движения вправо

Шаги:

Вызвать player.move_right(5)

Проверить изменения атрибутов

Ожидаемые результаты:

player.x_vel == 5

player.direction == "right"

---

Test Case 4: Одиночный прыжок

Метод: test_jump_mechanics() (первая часть)

Цель: Проверить механику первого прыжка

Шаги:

Вызвать player.jump()

Проверить изменения атрибутов

Ожидаемые результаты:

player.y_vel < 0 (движение вверх)

player.jump_count == 1

---

Test Case 5: Двойной прыжок

Метод: test_jump_mechanics() (вторая часть)

Цель: Проверить механику второго прыжка

Шаги:

Выполнить первый прыжок

Вызвать player.jump() повторно

Проверить изменения атрибутов

Ожидаемые результаты:

player.jump_count == 2

player.y_vel < -player.GRAVITY*6 (более сильный толчок)

---

Test Case 6: Приземление

Метод: test_landing()

Цель: Проверить сброс параметров при приземлении

Шаги:

Установить player.y_vel = 10 и player.fall_count = 30

Вызвать player.landed()

Проверить изменения атрибутов

Ожидаемые результаты:

player.y_vel == 0

player.fall_count == 0

player.jump_count == 0

---

#### **Для test2:**

---

**Test Case 1:** Движение врага по платформе  
**Соответствует тесту:** `test_movement_on_platform()`  
**Цель:** Проверить базовое движение врага вправо при наличии платформы  

**Шаги:**  
1. Создать врага в позиции (100, 100)  
2. Создать платформу в позиции (100, 150)  
3. Вызвать enemy.loop([platform])  

**Ожидаемые результаты:**  
- Позиция X врага увеличилась на 2 (100 → 102)  
- Направление осталось "right"  
- Спрайт остался синим (color=1)  

---

**Test Case 2:** Смена направления движения  
**Соответствует тесту:** `test_direction_change()`  
**Цель:** Проверить корректность смены направления на левое  

**Шаги:**  
1. Создать врага в стандартном состоянии  
2. Установить move_direction = -1  
3. Вызвать enemy.loop([])  

**Ожидаемые результаты:**  
- Позиция X уменьшилась на 2 (100 → 98)  
- Направление изменилось на "left"  
- Спрайт переключился на "slime_blue_left"  

---

**Test Case 3:** Обновление спрайта при движении  
**Соответствует тесту:** `test_sprite_change()`  
**Цель:** Проверить смену спрайта после движения  

**Шаги:**  
1. Создать врага и зафиксировать начальный спрайт  
2. Вызвать enemy.loop([platform])  
3. Сравнить спрайт до и после  

**Ожидаемые результаты:**  
- Спрайт изменился после движения  
- Новый спрайт соответствует направлению  

---

**Test Case 4:** Обработка столкновения  
**Соответствует тесту:** `test_simple_collision()`  
**Цель:** Проверить поведение при приближении к стене  

**Шаги:**  
1. Создать врага в позиции (180, 100)  
2. Создать стену в позиции (200, 100)  
3. Вызвать enemy.loop([wall])  

**Ожидаемые результаты:**  
- Позиция X увеличилась на 2 (180 → 182)  
- Движение продолжилось в том же направлении  
- (В реальной реализации должен быть разворот)  

---

#### **Для обучающих элементов:**

---

#### **Test Case 1:** Инициализация LearningElement  
**Метод:** `test_initialization()`  
**Цель:** Проверить корректность создания объекта LearningElement  

**Шаги:**  
1. Создать объект LearningElement с вопросом "Test question"  

**Ожидаемые результаты:**  
- `element.question == "Test question"`  
- `element.answered == False`  

---

#### **Test Case 2:** Отображение вопроса LearningElement  
**Метод:** `test_display_question()`  
**Цель:** Проверить отрисовку вопроса на экране  

**Шаги:**  
1. Инициализировать Pygame и создать экран  
2. Создать объект LearningElement с вопросом "Test question"  
3. Вызвать `display_question(screen, font)`  

**Ожидаемые результаты:**  
- Вопрос отображается без ошибок  
- Программа не завершается с исключениями  

---

#### **Test Case 3:** Награда за правильный ответ  
**Метод:** `test_reward()`  
**Цель:** Проверить обработку правильного ответа  

**Шаги:**  
1. Инициализировать Pygame  
2. Создать объект LearningElement  
3. Вызвать метод `reward(screen, font)`  

**Ожидаемые результаты:**  
- `element.answered == True`  
- На экране отображается сообщение о награде  

---

#### **Test Case 4:** Наказание за неправильный ответ  
**Метод:** `test_punish()`  
**Цель:** Проверить обработку неправильного ответа  

**Шаги:**  
1. Инициализировать Pygame  
2. Создать объект LearningElement  
3. Вызвать метод `punish(screen, font)`  

**Ожидаемые результаты:**  
- `element.answered == False`  
- На экране отображается сообщение о наказании  

---

#### **Test Case 5:** Инициализация MultipleChoiceQuestion  
**Метод:** `test_initialization()`  
**Цель:** Проверить создание объекта MultipleChoiceQuestion  

**Шаги:**  
1. Создать объект с вопросом "Test question", 3 вариантами ответа и правильным индексом 1  

**Ожидаемые результаты:**  
- `mcq.question == "Test question"`  
- `mcq.options == ["Option 1", "Option 2", "Option 3"]`  
- `mcq.correct_answer_index == 1`  
- `mcq.answered == False`  
- `mcq.option_rects == []` (до отображения)  

---

#### **Test Case 6:** Отображение вопроса с вариантами  
**Метод:** `test_display_question()`  
**Цель:** Проверить отрисовку вопроса и вариантов ответа  

**Шаги:**  
1. Инициализировать Pygame  
2. Создать объект MultipleChoiceQuestion  
3. Вызвать `display_question(screen, font)`  

**Ожидаемые результаты:**  
- `len(mcq.option_rects) == 3` (по количеству вариантов)  
- На экране отображаются все варианты ответа  

---

#### **Test Case 7:** Проверка правильного ответа  
**Метод:** `test_check_answer_correct()`  
**Цель:** Проверить обработку правильного выбора  

**Шаги:**  
1. Инициализировать Pygame и отобразить вопрос  
2. Создать фиктивную позицию мыши в центре правильного варианта (индекс 1)  
3. Вызвать `check_answer(test_pos, screen, font)`  

**Ожидаемые результаты:**  
- Возвращает `True`  
- `mcq.answered == True`  

---

#### **Test Case 8:** Проверка неправильного ответа  
**Метод:** `test_check_answer_incorrect()`  
**Цель:** Проверить обработку неправильного выбора  

**Шаги:**  
1. Инициализировать Pygame и отобразить вопрос  
2. Создать фиктивную позицию мыши в центре неправильного варианта (индекс 0)  
3. Вызвать `check_answer(test_pos, screen, font)`  

**Ожидаемые результаты:**  
- Возвращает `False`  
- `mcq.answered == False`  

---

#### **Для test3:**

---

**Test Case 1: Инициализация объекта клубники**  
**Соответствующий метод:** `test_strawberry_initial_state()`  

**Цель:**  
Проверить корректность начальных параметров при создании объекта клубники  

**Шаги:**  
1. Создать экземпляр класса Strawberry с координатами (100, 200) и размером 32x32 пикселя  
2. Проверить установленные атрибуты  

**Ожидаемый результат:**  
- Координаты: x=100, y=200  
- Параметры анимации:  
  - Базовая позиция (base_y) = 200  
  - Амплитуда колебаний = 5 пикселей  
  - Скорость анимации = 0.05  
  - Начальное время = 0  

---

**Test Case 2: Обновление анимации**  
**Соответствующий метод:** `test_strawberry_update_animation()`  

**Цель:**  
Проверить корректность работы механизма анимации  

**Шаги:**  
1. Выполнить метод update()  
2. Зафиксировать изменения состояния  

**Ожидаемый результат:**  
- Время (time) увеличилось на 0.05  
- Позиция y изменилась согласно формуле:  
  `новая позиция = базовая позиция + sin(время) * амплитуда`  
- Координата y отличается от начального значения  

---

**Test Case 3: Отрисовка объекта**  
**Соответствующий метод:** `test_strawberry_draw()`  

**Цель:**  
Проверить правильность отображения клубники на экране  

**Шаги:**  
1. Создать mock-объект окна  
2. Вызвать метод draw с offset_x=50  
3. Проверить параметры отрисовки  

**Ожидаемый результат:**  
- Метод blit вызван один раз  
- Параметры отрисовки:  
  - Изображение: strawberry.image  
  - Позиция: (100-50, текущая позиция y)  

---

**Test Case 4: Многократное обновление**  
**Соответствующий метод:** `test_multiple_updates()`  

**Цель:**  
Проверить стабильность анимации при длительной работе  

**Шаги:**  
1. Выполнить 5 последовательных вызовов update()  
2. Записать изменения позиции  
3. Проанализировать результаты  

**Ожидаемый результат:**  
- Каждое обновление дает новое значение позиции y  
- Все значения остаются в диапазоне: 195 ≤ y ≤ 205  
- Отсутствуют резкие скачки положения  
- Анимация плавная и предсказуемая  
