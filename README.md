### Тест-кейсы для test1.py (Класс Player)

**Test Case 1: Проверка начального состояния игрока**  
Метод: `test_player_initial_state()`  
Цель: Проверить корректность инициализации объекта игрока  
Шаги:
1. Создать объект Player с параметрами (100, 100, 50, 50)
2. Проверить начальные значения атрибутов  

Ожидаемые результаты:
- `player.rect.x == 100`
- `player.rect.y == 100`
- `player.direction == "right"`
- `player.jump_count == 0`
- `player.y_vel == 0`

**Test Case 2: Базовый прыжок**  
Метод: `test_player_jump()`  
Цель: Проверить механику одиночного прыжка  
Шаги:
1. Вызвать `player.jump()`
2. Проверить изменения атрибутов  

Ожидаемые результаты:
- `player.y_vel < 0` (движение вверх)
- `player.jump_count == 1`

**Test Case 3: Двойной прыжок**  
Метод: `test_double_jump()`  
Цель: Проверить механику двойного прыжка  
Шаги:
1. Вызвать `player.jump()`
2. Зафиксировать скорость первого прыжка
3. Вызвать `player.jump()` повторно  

Ожидаемые результаты:
- Скорость второго прыжка больше первого
- `player.jump_count == 2`

**Test Case 4: Движение влево**  
Метод: `test_player_movement()` (первая часть)  
Цель: Проверить корректность движения влево  
Шаги:
1. Вызвать `player.move_left(5)`  

Ожидаемые результаты:
- `player.x_vel == -5`
- `player.direction == "left"`

**Test Case 5: Движение вправо**  
Метод: `test_player_movement()` (вторая часть)  
Цель: Проверить корректность движения вправо  
Шаги:
1. Вызвать `player.move_right(5)`  

Ожидаемые результаты:
- `player.x_vel == 5`
- `player.direction == "right"`

**Test Case 6: Ошибка приземления**  
Метод: `test_player_landing()`  
Цель: Выявить ошибку проваливания в блок  
Шаги:
1. Расположить игрока над блоком
2. Вызвать `player.landed()`  

Ожидаемые результаты:
- `player.rect.bottom == block.rect.top` (FAIL - игрок проваливается)

### Тест-кейсы для test2.py (Классы Enemy и Object)

**Test Case 7: Движение врага**  
Метод: `test_enemy_movement()`  
Цель: Проверить ИИ перемещения врага  
Шаги:
1. Поместить врага на платформе
2. Запустить 10 циклов движения  

Ожидаемые результаты:
- Направление движения изменилось

**Test Case 8: Обнаружение столкновений врага**  
Метод: `test_enemy_collision_detection()`  
Цель: Проверить обработку коллизий  
Шаги:
1. Расположить врага вплотную к блоку
2. Проверить реакцию на столкновение  

Ожидаемые результаты:
- `enemy.check_collision()` возвращает True

**Test Case 9: Анимация клубнички**  
Метод: `test_strawberry_animation()`  
Цель: Проверить работу анимации  
Шаги:
1. Зафиксировать начальную позицию
2. Вызвать `strawberry.update()`  

Ожидаемые результаты:
- Позиция Y изменилась

### Тест-кейсы для test3.py (Взаимодействия)

**Test Case 10: Сбор клубнички**  
Метод: `test_strawberry_collection()`  
Цель: Проверить механику сбора  
Шаги:
1. Совместить позиции игрока и клубнички
2. Вызвать `collide()`  

Ожидаемые результаты:
- Клубничка удалена из списка объектов

**Test Case 11: Ошибка производительности**  
Метод: `test_strawberry_collection_performance()`  
Цель: Выявить проблему с производительностью  
Шаги:
1. Замерить время выполнения `collide()`  

Ожидаемые результаты:
- Время выполнения < 0.1 сек (FAIL - искусственная задержка)

### **Тест-кейсы для `test_game.py` (Обучающие элементы)**

---

#### **Test Case 1: Проверка возврата `False` при промахе**  
**Метод:** `test_missed_click_returns_false()`  
**Цель:** Убедиться, что при клике мимо вариантов ответа возвращается `False`.  
**Шаги:**  
1. Создать вопрос с вариантами ответов.  
2. Сымитировать клик в координаты `(0, 0)` (вне зоны ответов).  
3. Проверить возвращаемое значение.  

**Ожидаемый результат:**  
- Метод `check_answer()` возвращает `False`.  

---

#### **Test Case 2: Проверка, что промах не меняет флаг `answered`**  
**Метод:** `test_missed_click_does_not_mark_answered()`  
**Цель:** Убедиться, что флаг `answered` остается `False` при клике мимо вариантов.  
**Шаги:**  
1. Создать вопрос.  
2. Сымитировать клик вне зоны ответов.  
3. Проверить значение `answered`.  

**Ожидаемый результат:**  
- `answered == False`.  

---

#### **Test Case 3: Проверка отметки вопроса как отвеченного при правильном ответе**  
**Метод:** `test_correct_answer_marks_answered()`  
**Цель:** Убедиться, что при правильном ответе флаг `answered` становится `True`.  
**Шаги:**  
1. Создать вопрос.  
2. Сымитировать клик по правильному варианту.  
3. Проверить значение `answered`.  

**Ожидаемый результат:**  
- `answered == True`.  

---

#### **Test Case 4: Проверка создания прямоугольников для кликов**  
**Метод:** `test_option_rects_created()`  
**Цель:** Убедиться, что для каждого варианта ответа создается `pygame.Rect`.  
**Шаги:**  
1. Создать вопрос.  
2. Вызвать `display_question()`.  
3. Проверить список `option_rects`.  

**Ожидаемые результаты:**  
- `len(option_rects) == len(options)`.  
- Каждый элемент `option_rects` — экземпляр `pygame.Rect`.  

---

#### **Test Case 5: Проверка исправленного поведения при промахе**  
**Метод:** `test_fixed_missed_click()`  
**Цель:** Убедиться, что исправленная версия возвращает `False` при промахе.  
**Шаги:**  
1. Создать исправленный вопрос (`FixedMultipleChoiceQuestion`).  
2. Сымитировать клик вне зоны ответов.  
3. Проверить возвращаемое значение и флаг `answered`.  

**Ожидаемые результаты:**  
- Возвращается `False`.  
- `answered == False`.  

---
